---
title: "Authentication"
---

This article describes the authentication methods required for using the WaaS service.

To ensure secure access to your crypto assets via APIs, the WaaS service validates the use of ECDSA signatures for authentication in all API calls. Access to the API is denied without proper authentication. You need to provide an API key, a nonce, and an API signature in the request header as follows. 

<Note>If you are using Cobo's WaaS SDKs, you can skip this section because the SDKs already encapsulate the authentication mechanism for you.</Note>


```curl
headers = {
"Biz-Api-Key": api_key.hex(),
"Biz-Api-Nonce": timestamp,
"Biz-Api-Signature": signature.hex(),
}
```

| Field | Description | 
| ----------- | ----------- |
| `Biz-Api-KeyAPI` | An API key. To learn how to create an API key, see [API key]().    |
| `Biz-Api-Nonce`  | Nonce. The time when the request is sent in Unix timestamp format, measured in milliseconds. | 
| `Biz-Api-Signature` | An API signature. Cobo API Key authentication requires each request to be signed except public API interfaces. To learn how to create an API signature, see [Generate an API signature](#generate-an-api-signature).  | 

### Generate an API signature

1. Concatenate the string to be signed

    First, concatenate the string to be signed by linking required fields.

    str_to_sign = `{METHOD}|{PATH}|{TIMESTAMP}|{PARAMS}|{BODY}`

    | Field | Description | Example |
    | ----------- | ----------- |----------- |
    | METHOD     | The HTTP method.   | `GET` |
    | PATH  | The request path.   | `/v2/transactions/transfer` |
    | TIMESTAMP  | The current time in Unix timestamp format, measured in milliseconds. | `1718587017026` |
    | PARAMS   | The query parameters. To learn more about available query parameters, see [Query parameters](#query-parameters). | `chain_id=ETH&limit=10` |
    | BODY   | The request raw body in string format.  | `{"name":"Default","wallet_subtype":"Asset","wallet_type":"Custodial"}` |

2. Perform SHA-256 hashing twice on the string

    Use the `hashlib` library to perform SHA-256 hashing twice on the string as follows:
    ```python
    import hashlib

    content_hash = hashlib.sha256(hashlib.sha256(str_to_sign.encode()).digest()).digest()
    ```

3. Generate an Ed25519 key pair

    You can use either OpenSSL or the Python library `nacl` to generate an Ed25519 key pair.

    - Using OpenSSL

        In a terminal window, run the following OpenSSL commands:

        ```bash
        # Generate a private key and save it in the `private.key.pen` file.
        openssl genpkey -algorithm ed25519 -out private_key.pem
        # Extract the public key from the private key and save it in the `public.key.pen` file.
        openssl pkey -in private_key.pem -pubout -out public_key.pem
        # Export the private key in hexadecimal format.
        openssl pkey -in private_key.pem -text | grep 'priv:' -A 3 | tail -n +2 | tr -d ':\n '
        # Export the public key in hexadecimal format.
        openssl pkey -pubin -in public_key.pem -text | grep 'pub:' -A 3 | tail -n +2 | tr -d ':\n '
        ```

    - Using the `nacl` Python library

        1. Install the `nacl` library

            In a terminal window, run the following command:

            ```bash
            pip install nacl
            ```

        2. Generate a key pair

            Use the `nacl` library to generate a key pair as follows:

            ```python
            import nacl.signing

            # Generate a signing key (private key)
            signing_key = nacl.signing.SigningKey.generate()

            # Get the private key in hexadecimal format
            private_key_hex = signing_key.private_key.encode(encoder=nacl.encoding.HexEncoder).decode()

            # Get the public key in hexadecimal format
            public_key_hex = signing_key.verify_key.encode(encoder=nacl.encoding.HexEncoder).decode()
            ```

4. Sign the string with the private key

    Use the Ed25519 private key to sign the string as follows:

    ```python
    # Import the `nacl` library if you haven't.
    import nacl.signing

    # Create an Ed25519 signing Key
    sk = ed25519.SigningKey(sk_s=bytes.fromhex(api_secret))
    # Sign the hashed message
    signature = sk.sign(content_hash)
    ```

Now you've generated an API signature.